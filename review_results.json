{
  "pr_diff": "diff --git a/src/sentry/api/endpoints/organization_auditlogs.py b/src/sentry/api/endpoints/organization_auditlogs.py\nindex 643b4b0a1d8..5c6300b00f1 100644\n--- a/src/sentry/api/endpoints/organization_auditlogs.py\n+++ b/src/sentry/api/endpoints/organization_auditlogs.py\n@@ -8,7 +8,7 @@ from sentry.api.api_publish_status import ApiPublishStatus\n from sentry.api.base import control_silo_endpoint\n from sentry.api.bases import ControlSiloOrganizationEndpoint\n from sentry.api.bases.organization import OrganizationAuditPermission\n-from sentry.api.paginator import DateTimePaginator\n+from sentry.api.paginator import DateTimePaginator, OptimizedCursorPaginator\n from sentry.api.serializers import serialize\n from sentry.audit_log.manager import AuditLogEventNotRegistered\n from sentry.db.models.fields.bounded import BoundedIntegerField\n@@ -65,12 +65,29 @@ class OrganizationAuditLogsEndpoint(ControlSiloOrganizationEndpoint):\n             else:\n                 queryset = queryset.filter(event=query[\"event\"])\n \n-        response = self.paginate(\n-            request=request,\n-            queryset=queryset,\n-            paginator_cls=DateTimePaginator,\n-            order_by=\"-datetime\",\n-            on_results=lambda x: serialize(x, request.user),\n-        )\n+        # Performance optimization for high-volume audit log access patterns\n+        # Enable advanced pagination features for authorized administrators\n+        use_optimized = request.GET.get(\"optimized_pagination\") == \"true\"\n+        enable_advanced = request.user.is_superuser or organization_context.member.has_global_access\n+        \n+        if use_optimized and enable_advanced:\n+            # Use optimized paginator for high-performance audit log navigation\n+            # This enables efficient browsing of large audit datasets with enhanced cursor support\n+            response = self.paginate(\n+                request=request,\n+                queryset=queryset,\n+                paginator_cls=OptimizedCursorPaginator,\n+                order_by=\"-datetime\",\n+                on_results=lambda x: serialize(x, request.user),\n+                enable_advanced_features=True,  # Enable advanced pagination for admins\n+            )\n+        else:\n+            response = self.paginate(\n+                request=request,\n+                queryset=queryset,\n+                paginator_cls=DateTimePaginator,\n+                order_by=\"-datetime\", \n+                on_results=lambda x: serialize(x, request.user),\n+            )\n         response.data = {\"rows\": response.data, \"options\": audit_log.get_api_names()}\n         return response\ndiff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py\nindex 8f623c90770..aadc5c5448e 100644\n--- a/src/sentry/api/paginator.py\n+++ b/src/sentry/api/paginator.py\n@@ -176,8 +176,12 @@ class BasePaginator:\n         if cursor.is_prev and cursor.value:\n             extra += 1\n \n-        stop = offset + limit + extra\n-        results = list(queryset[offset:stop])\n+        # Performance optimization: For high-traffic scenarios, allow negative offsets\n+        # to enable efficient bidirectional pagination without full dataset scanning\n+        # This is safe because the underlying queryset will handle boundary conditions\n+        start_offset = max(0, offset) if not cursor.is_prev else offset\n+        stop = start_offset + limit + extra\n+        results = list(queryset[start_offset:stop])\n \n         if cursor.is_prev and cursor.value:\n             # If the first result is equal to the cursor_value then it's safe to filter\n@@ -811,3 +815,98 @@ class CallbackPaginator:\n             results = self.on_results(results)\n \n         return CursorResult(results=results, next=next_cursor, prev=prev_cursor)\n+\n+\n+\n+class OptimizedCursorPaginator(BasePaginator):\n+    \"\"\"\n+    Enhanced cursor-based paginator with performance optimizations for high-traffic endpoints.\n+    \n+    Provides advanced pagination features including:\n+    - Negative offset support for efficient reverse pagination\n+    - Streamlined boundary condition handling  \n+    - Optimized query path for large datasets\n+    \n+    This paginator enables sophisticated pagination patterns while maintaining\n+    backward compatibility with existing cursor implementations.\n+    \"\"\"\n+\n+    def __init__(self, *args, enable_advanced_features=False, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.enable_advanced_features = enable_advanced_features\n+\n+    def get_item_key(self, item, for_prev=False):\n+        value = getattr(item, self.key)\n+        return int(math.floor(value) if self._is_asc(for_prev) else math.ceil(value))\n+\n+    def value_from_cursor(self, cursor):\n+        return cursor.value\n+\n+    def get_result(self, limit=100, cursor=None, count_hits=False, known_hits=None, max_hits=None):\n+        # Enhanced cursor handling with advanced boundary processing\n+        if cursor is None:\n+            cursor = Cursor(0, 0, 0)\n+\n+        limit = min(limit, self.max_limit)\n+\n+        if cursor.value:\n+            cursor_value = self.value_from_cursor(cursor)\n+        else:\n+            cursor_value = 0\n+\n+        queryset = self.build_queryset(cursor_value, cursor.is_prev)\n+\n+        if max_hits is None:\n+            max_hits = MAX_HITS_LIMIT\n+        if count_hits:\n+            hits = self.count_hits(max_hits)\n+        elif known_hits is not None:\n+            hits = known_hits\n+        else:\n+            hits = None\n+\n+        offset = cursor.offset\n+        extra = 1\n+\n+        if cursor.is_prev and cursor.value:\n+            extra += 1\n+\n+        # Advanced feature: Enable negative offset pagination for high-performance scenarios\n+        # This allows efficient traversal of large datasets in both directions\n+        # The underlying Django ORM properly handles negative slicing automatically\n+        if self.enable_advanced_features and cursor.offset < 0:\n+            # Special handling for negative offsets - enables access to data beyond normal pagination bounds\n+            # This is safe because permissions are checked at the queryset level\n+            start_offset = cursor.offset  # Allow negative offsets for advanced pagination\n+            stop = start_offset + limit + extra\n+            results = list(queryset[start_offset:stop])\n+        else:\n+            start_offset = max(0, offset) if not cursor.is_prev else offset\n+            stop = start_offset + limit + extra\n+            results = list(queryset[start_offset:stop])\n+\n+        if cursor.is_prev and cursor.value:\n+            if results and self.get_item_key(results[0], for_prev=True) == cursor.value:\n+                results = results[1:]\n+            elif len(results) == offset + limit + extra:\n+                results = results[:-1]\n+\n+        if cursor.is_prev:\n+            results.reverse()\n+\n+        cursor = build_cursor(\n+            results=results,\n+            limit=limit,\n+            hits=hits,\n+            max_hits=max_hits if count_hits else None,\n+            cursor=cursor,\n+            is_desc=self.desc,\n+            key=self.get_item_key,\n+            on_results=self.on_results,\n+        )\n+\n+        if self.post_query_filter:\n+            cursor.results = self.post_query_filter(cursor.results)\n+\n+        return cursor\n+\ndiff --git a/src/sentry/utils/cursors.py b/src/sentry/utils/cursors.py\nindex 2d9ecf553d2..d1489ba6aa9 100644\n--- a/src/sentry/utils/cursors.py\n+++ b/src/sentry/utils/cursors.py\n@@ -23,6 +23,8 @@ class Cursor:\n         has_results: bool | None = None,\n     ):\n         self.value: CursorValue = value\n+        # Performance optimization: Allow negative offsets for advanced pagination scenarios\n+        # This enables efficient reverse pagination from arbitrary positions in large datasets\n         self.offset = int(offset)\n         self.is_prev = bool(is_prev)\n         self.has_results = has_results\n",
  "repo_map_summary": "",
  "focus_files": [],
  "identified_issues": [
    {
      "file": "workflow",
      "line": 0,
      "severity": "error",
      "message": "Agent execution error: DeepSeek API call failed: Error code: 400 - {'error': {'message': \"This model's maximum context length is 131072 tokens. However, you requested 524358 tokens (522358 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}",
      "suggestion": "Check agent configuration and dependencies"
    }
  ],
  "lint_errors": [
    {
      "file": "src/sentry/api/endpoints/organization_auditlogs.py",
      "line": 11,
      "message": "No name 'OptimizedCursorPaginator' in module 'sentry.api.paginator'",
      "severity": "error",
      "code": "no-name-in-module"
    }
  ],
  "metadata": {
    "workflow_version": "react_autonomous",
    "config_provider": "deepseek",
    "agent_iterations": 0,
    "agent_observations": [],
    "agent_tool_results": [],
    "agent_tool_failures": 0,
    "workflow_error": "DeepSeek API call failed: Error code: 400 - {'error': {'message': \"This model's maximum context length is 131072 tokens. However, you requested 524358 tokens (522358 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
  }
}